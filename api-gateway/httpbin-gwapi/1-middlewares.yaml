apiVersion: traefik.io/v1alpha1
kind: Middleware
metadata:
  name: strip-httpbin-prefix
  namespace: apps
spec:
  stripPrefix:
    prefixes:
      - "/httpbin"
---
apiVersion: traefik.io/v1alpha1
kind: Middleware
metadata:
  name: custom-header
  namespace: apps
spec:
  headers:
    customRequestHeaders:
      X-Custom-Header: "Hello Traefik"
---
apiVersion: traefik.io/v1alpha1
kind: Middleware
metadata:
  name: ratelimit
  namespace: apps
spec:
  rateLimit:
    average: 10
    burst: 100
    period: 1s
---
apiVersion: traefik.io/v1alpha1
kind: Middleware
metadata:
  name: keycloak-jwt-authentication
  namespace: apps
spec:
  plugin:
    jwt:
      jwksUrl: http://keycloak-service.traefik-security.svc:8080/realms/traefik/protocol/openid-connect/certs
      forwardHeaders:
        Group: group
---
apiVersion: traefik.io/v1alpha1
kind: Middleware
metadata:
  name: waf
  namespace: apps
spec:
  plugin:
    coraza:
      crsEnabled: true
      directives:
        - SecRuleEngine On
        - SecRule REQUEST_URI "@streq /anything/admin" "id:101,phase:1,t:lowercase,log,deny"
        - SecRule REQUEST_METHOD "@streq GET" "id:201,phase:1,log,deny,status:403,msg:'Blocked GET containing /admin',chain"
        - SecRule REQUEST_URI "@rx /admin"
        - Include @owasp_crs/REQUEST-911-METHOD-ENFORCEMENT.conf
        - Include @owasp_crs/REQUEST-932-APPLICATION-ATTACK-RCE.conf
        - Include @owasp_crs/REQUEST-933-APPLICATION-ATTACK-PHP.conf
        - Include @owasp_crs/REQUEST-942-APPLICATION-ATTACK-SQLI.conf
---
apiVersion: traefik.io/v1alpha1
kind: Middleware
metadata:
  name: cache
  namespace: apps
spec:
  plugin:
    httpCache:
      maxTtl: 600
      store:
        memory:
          limit: "3Gi"

---          

apiVersion: traefik.io/v1alpha1
kind: Middleware
metadata:
  name: opa-spain-geoblocking
  namespace: apps
spec:
  plugin:
    opa:
      policy: |
        package traefik.geoblocking
        
        import rego.v1
        
        default allow := false
        default message := "Access denied"
        
        # Check multiple possible country headers
        country_code := code if {
            code := input.headers["CF-IPCountry"]
        } else := code if {
            code := input.headers["CloudFront-Viewer-Country"]  
        } else := code if {
            code := input.headers["X-Country-Code"]
        } else := code if {
            code := input.headers["X-Forwarded-Country"]
        } else := ""
        
        # Block Spain
        allow if {
            country_code != "ES"
            message := sprintf("Access granted from country: %s", [country_code])
        }
        
        # Explicit denial for Spain
        deny[msg] if {
            country_code == "ES"
            msg := "Access blocked: Spanish IP addresses are not allowed"
        }
        
      forwardHeaders:
        Country: data.traefik.geoblocking.country_code
        GeoMessage: data.traefik.geoblocking.message

---
apiVersion: traefik.io/v1alpha1
kind: Middleware
metadata:
  name: opa-jwt-validation
  namespace: apps
spec:
  plugin:
    opa:
      policy: |
        package traefik.jwt
        
        import rego.v1
        
        default allow := false
        default user_type := "unknown"
        default user_email := ""
        default user_groups := []
        
        # Extract JWT token from Authorization header
        token_payload := payload if {
            [_, encoded] := split(input.headers.Authorization, " ")
            [_, payload, _] := io.jwt.decode(encoded)
        }
        
        # Extract user information
        user_type := "service_account" if {
            token_payload.preferred_username == "service-account-traefik"
            token_payload.client_id == "traefik"
        }
        
        user_type := "developer" if {
            token_payload.preferred_username == "developer"
            "developers" in token_payload.group
        }
        
        user_email := token_payload.email if {
            token_payload.email
        }
        
        user_groups := token_payload.group if {
            token_payload.group
        }
        
        # Token validation
        valid_token if {
            token_payload.azp == "traefik"
            token_payload.typ == "Bearer"
            now := time.now_ns() / 1000000000
            token_payload.exp > now
        }
        
        # Allow service accounts
        allow if {
            valid_token
            user_type == "service_account"
            contains(token_payload.iss, "/realms/traefik")
            "uma_protection" in token_payload.resource_access.traefik.roles
        }
        
        # Allow developers
        allow if {
            valid_token
            user_type == "developer" 
            contains(token_payload.iss, "/realms/traefik")
            token_payload.email_verified == true
            "developers" in token_payload.group
        }